{
  "version": 3,
  "sources": ["../../src/core.js", "../../src/filtering.js", "../../src/traversal.js", "../../src/state.js", "../../src/component.js", "../../src/template.js", "../../src/morph.js", "../../src/element.js", "../../src/request.js", "../../src/animate.js", "../../src/prebuilt.js", "../../src/dom.js", "../../src/attributes.js", "../../src/events.js", "../../src/alias.js", "../../src/utilities.js", "../../src/extend.js"],
  "sourcesContent": ["// Check if AnJS is already defined globally\nconst globalScope = typeof window !== \"undefined\" ? window : global;\n\n// Check if AnJS is already defined globally\nif (!globalScope.__AnJS__) {\n\n    // Core Selector Class\n    class AnJS extends Array {\n\n        /**\n         * Initialize AnJS\n         * \n         * @param {string | HTMLElement | NodeList} query - CSS selector or element.\n         */\n        constructor(query) {\n\n            // Initialize\n            super();\n\n            // Return if no query is provided\n            if (!query) return;\n\n            // Handle an Element\n            if (query instanceof HTMLElement || query.nodeType === 1) this.push(query);\n\n            // Handle NodeList or Array\n            else if (query instanceof NodeList || Array.isArray(query)) this.push(...query);\n            \n            // Handle CSS selector string\n            else if (typeof query === \"string\") this.push(...document.querySelectorAll(query));\n        }\n\n        /**\n         * Iterate through elements\n         * \n         * @param {Function} fn - Callback function.\n         * @returns {AnJS} - Returns self for chaining.\n         */\n        each(fn) {\n\n            // Iterate over selected elements\n            this.forEach(fn);\n\n            // Chainable\n            return this;\n        }\n\n        /**\n         * Get elements by index or return all\n         * \n         * @param {number} [index] - The index of the element to retrieve.\n         * @returns {HTMLElement | Array} - The specific element or an array of elements.\n         */\n        get(index) {\n\n            // Return all elements if no index is provided\n            return index === undefined ? this : this.at(index);\n        }\n\n        /**\n         * Clone the first selected element\n         * \n         * @param {boolean} [deep=true] - Clone children.\n         * @returns {HTMLElement | null} - Cloned element.\n         */\n        clone(deep = true) {\n\n            // Clone first element (shallow or deep)\n            return this[0] ? this[0].cloneNode(deep) : null;\n        }\n    }\n    \n    // Assign AnJS to a global variable\n    globalScope.__AnJS__ = AnJS;\n}\n\n// Export the globally defined AnJS class\nexport default globalScope.__AnJS__;", "// Dependencies\nimport AnJS from './core.js';\n\n// Batch assign filtering methods to AnJS prototype\nObject.assign(AnJS.prototype, {\n\n    /**\n     * Filter elements based on a callback function or CSS selector\n     * \n     * @param {Function | string} callbackOrSelector - Callback function or CSS selector.\n     * @returns {AnJS} - Returns a new instance of AnJS.\n     */\n    filter(callbackOrSelector) {\n\n        // If a function is provided, use native Array filter\n        if (typeof callbackOrSelector === \"function\") return new AnJS([...this].filter(callbackOrSelector));\n\n        // Otherwise, assume it's a CSS selector and filter elements that match\n        return new AnJS([...this].filter(el => el.matches(callbackOrSelector)));\n    },\n\n    /**\n     * Find child elements by a CSS selector\n     * \n     * @param {string} selector - CSS selector to find child elements.\n     * @returns {AnJS} - Returns a new instance of AnJS.\n     */\n    find(selector) {\n\n        // Select all matching children of each element in the collection\n        return new AnJS(this.flatMap(el => [...el.querySelectorAll(selector)]));\n    },\n\n    /**\n     * Select the first element from the current selection\n     * \n     * @returns {AnJS} - Returns a new instance of AnJS.\n     */\n    first() {\n\n        // Keep only the first element\n        return new AnJS(this.length ? [this[0]] : []);\n    },\n\n    /**\n     * Select the last element from the current selection\n     * \n     * @returns {AnJS} - Returns a new instance of AnJS.\n     */\n    last() {\n\n        // Keep only the last element\n        return new AnJS(this.length ? [this[this.length - 1]] : []);\n    },\n\n    /**\n     * Select only elements with an even index\n     * \n     * @returns {AnJS} - Returns a new instance of AnJS.\n     */\n    even() {\n\n        // Select elements with even indices\n        return new AnJS(this.filter((_, index) => !(index % 2)));\n    },\n\n    /**\n     * Select only elements with an odd index\n     * \n     * @returns {AnJS} - Returns a new instance of AnJS.\n     */\n    odd() {\n\n        // Select elements with odd indices\n        return new AnJS(this.filter((_, index) => index % 2));\n    }\n});", "// Dependencies\nimport AnJS from \"./core.js\";\n\n// Batch assign traversal methods to AnJS prototype\nObject.assign(AnJS.prototype, {\n\n    /**\n     * Select the next sibling element\n     * \n     * @returns {AnJS} - New AnJS instance with the next sibling.\n     */\n    next() {\n\n        // Check if the first element exists and has a next sibling\n        return new AnJS(this[0]?.nextElementSibling ? [this[0].nextElementSibling] : []);\n    },\n\n    /**\n     * Select the previous sibling element\n     * \n     * @returns {AnJS} - New AnJS instance with the previous sibling.\n     */\n    prev() {\n\n        // Check if the first element exists and has a previous sibling\n        return new AnJS(this[0]?.previousElementSibling ? [this[0].previousElementSibling] : []);\n    },\n\n    /**\n     * Select the parent element\n     * \n     * @returns {AnJS} - New AnJS instance with the parent.\n     */\n    parent() {\n\n        // Check if the first element exists and has a parent\n        return new AnJS(this[0]?.parentElement ? [this[0].parentElement] : []);\n    },\n\n    /**\n     * Select child elements\n     * \n     * @returns {AnJS} - New AnJS instance with children.\n     */\n    children() {\n\n        // Check if the first element exists and has children\n        return new AnJS(this[0] ? [...this[0].children] : []);\n    },\n\n    /**\n     * Select all sibling elements\n     * \n     * @returns {AnJS} - New AnJS instance with all siblings except the current element.\n     */\n    siblings() {\n\n        // Get parent element\n        const parent = this[0]?.parentElement;\n\n        // Return siblings if parent exists, otherwise return empty\n        return new AnJS(parent ? [...parent.children].filter(el => el !== this[0]) : []);\n    },\n\n    /**\n     * Select the closest ancestor matching a selector\n     * \n     * @param {string} selector - CSS selector to match.\n     * @returns {AnJS} - New AnJS instance with the closest matching ancestor.\n     */\n    closest(selector) {\n\n        // Check if the first element exists and find the closest matching ancestor\n        return new AnJS(this[0]?.closest(selector) ? [this[0].closest(selector)] : []);\n    }\n});", "// Dependencies \nimport AnJS from './core.js';\n\n// Stores element bindings for reactive text updates (`data-bind`)\nexport const bindings = {};\n\n// Tracks scoped bindings per state instance\nexport const localBindings = new Map();\n\n// Global State Storage\nconst globalStates = (typeof window !== \"undefined\" && (window.__AnJS_GLOBAL_STATES__ ||= {})) || {};\n\n// Stores attribute bindings for reactive updates (`data-bind-attr`)\nconst attrBindings = {};\n\n// List of boolean attributes (handled differently from regular attributes)\nconst boolAttrs = new Set([\n    \"disabled\", \"checked\", \"selected\", \"readonly\", \"multiple\",\n    \"hidden\", \"autoplay\", \"controls\", \"loop\", \"muted\"\n]);\n\n/**\n * Retrieve or create a **global state**\n * \n * @param {string} name - The unique global state name.\n * @param {Object} [initial] - The initial state values (optional).\n * @param {Object} [options] - State options (`{ persist: \"local\" | \"session\" }`).\n * @returns {Proxy} - The reactive global state object.\n */\nAnJS.prototype.global = function (name, initial, options = {}) {\n\n    // Ensure valid state name\n    if (!name || typeof name !== \"string\") throw new Error(\"Global state must have a unique name.\");\n\n    // If no initial state and state doesn't exist, throw an error (restoring original test behavior)\n    if (!globalStates[name] && initial === undefined) throw new Error(`Global state \"${name}\" does not exist. Provide an initial state.`);\n\n    // Load persisted state if enabled\n    if (options.persist) {\n\n        // Determine storage type\n        const storage = options.persist === \"session\" ? sessionStorage : localStorage;\n\n        // Load saved state from storage\n        const saved = storage.getItem(name);\n\n        // Use saved state if available\n        if (saved) initial = JSON.parse(saved);\n    }\n\n    // Register new state only if it's missing\n    if (!globalStates[name] && initial !== undefined) {\n\n        // Create new global state\n        globalStates[name] = $.state(persistent(name, initial, options.persist));\n    }\n\n    // Return the global state\n    return globalStates[name];\n};\n\n/**\n * Clear a **global state** (removes from memory and storage)\n * \n * @param {string} name - The global state name to clear.\n */\nAnJS.prototype.clearGlobal = function (name) {\n\n    // Ensure the state exists before clearing\n    if (globalStates[name]) {\n\n        // Remove from in-memory storage\n        delete globalStates[name];\n\n        // Remove from persistent storage (local)\n        localStorage.removeItem(name);\n\n        // Remove from persistent storage (session)\n        sessionStorage.removeItem(name);\n    }\n};\n\n/**\n * Check if a global state exists\n * \n * @param {string} name - The global state name to check.\n * @returns {boolean} - `true` if the global state exists, otherwise `false`.\n */\nAnJS.prototype.hasGlobal = function (name) {\n\n    // Check if the state exists\n    return !!globalStates[name];\n};\n\n/**\n * Create a **reactive state object**\n * \n * @param {Object} initial - The initial state values.\n * @param {Object} [options] - Options for state behavior.\n * @returns {Proxy} - The reactive proxy object with onChange, onAny, patch.\n */\nAnJS.prototype.state = function (initial = {}, options = {}) {\n\n    // Handle global state registration\n    const isGlobal = !!options.global;\n\n    if (isGlobal) {\n\n        // Ensure a valid name is provided\n        if (!options.name) throw new Error(\"Global state must have a name.\");\n\n        // Register global state\n        initial = globalStates[options.name] ??= initial;\n    }\n\n    // Per-property change listeners \u2014 Map<string, Set<Function>>\n    const listeners = new Map();\n\n    // Batch queue \u2014 when non-null, defers notifications until batch ends\n    let batchQueue = null;\n\n    // Fire listeners for a specific property (and wildcards)\n    function notify(prop, value) {\n\n        // Fire property-specific listeners\n        const handlers = listeners.get(prop);\n        if (handlers) handlers.forEach(fn => fn(value, prop));\n\n        // Fire wildcard listeners\n        const wildcards = listeners.get('*');\n        if (wildcards) wildcards.forEach(fn => fn(value, prop));\n    }\n\n    // Create proxy for reactive updates\n    const proxy = new Proxy(initial, {\n\n        // Retrieve state property \u2014 also exposes onChange, onAny, patch as methods\n        get: (target, prop) => {\n\n            // Expose onChange as a non-enumerable method\n            if (prop === 'onChange') return (path, handler) => {\n                if (!listeners.has(path)) listeners.set(path, new Set());\n                listeners.get(path).add(handler);\n                return () => listeners.get(path)?.delete(handler);\n            };\n\n            // Expose onAny as convenience for wildcard\n            if (prop === 'onAny') return (handler) => {\n                if (!listeners.has('*')) listeners.set('*', new Set());\n                listeners.get('*').add(handler);\n                return () => listeners.get('*')?.delete(handler);\n            };\n\n            // Expose patch for batch updates\n            if (prop === 'patch') return (changes) => {\n                batchQueue = new Set();\n                for (const [key, val] of Object.entries(changes)) {\n                    proxy[key] = val;\n                }\n                const changed = batchQueue;\n                batchQueue = null;\n                for (const key of changed) {\n                    notify(key, target[key]);\n                }\n            };\n\n            return target[prop];\n        },\n\n        // Update state property & trigger UI updates\n        set: (target, prop, value) => {\n\n            // Assign new value\n            target[prop] = value;\n\n            // Only scan global bindings for global state (performance optimization)\n            if (isGlobal) {\n                Object.keys(bindings).forEach(bindKey => {\n\n                    // Handle nested properties (e.g., `cards.title`)\n                    let [root, ...rest] = bindKey.split(\".\");\n\n                    // Skip if the root object doesn't exist\n                    if (!bindings[bindKey]) return;\n\n                    // Update nested properties\n                    let nestedValue = rest.reduce((obj, key) => obj?.[key], globalStates[root]);\n\n                    // Update elements bound with `data-bind`\n                    bindings[bindKey].forEach(el => el.textContent = nestedValue ?? \"\");\n                });\n            }\n\n            // Update elements bound with `data-bind`\n            bindings[prop]?.forEach(el => el.textContent = value ?? \"\");\n\n            // Update elements bound with `data-bind-this`\n            localBindings.get(proxy)?.[prop]?.forEach(el => el.textContent = value ?? \"\");\n\n            // Update elements bound with `data-bind-attr`\n            attrBindings[prop]?.forEach(({ el, attr }) => {\n\n                // Decide whether to remove or set the attribute\n                value == null\n\n                    // Remove attribute if value is `null`\n                    ? el.removeAttribute(attr)\n\n                    // Set attribute value\n                    : boolAttrs.has(attr.toLowerCase()) ? el.toggleAttribute(attr, !!value) : el.setAttribute(attr, value);\n            });\n\n            // Fire onChange listeners (or queue if batching)\n            if (batchQueue) {\n                batchQueue.add(prop);\n            } else {\n                notify(prop, value);\n            }\n\n            return true;\n        }\n    });\n\n    // Store local bindings\n    localBindings.set(proxy, {});\n\n    // Auto-bind state to the DOM\n    this.bind(proxy);\n\n    // Return reactive proxy\n    return proxy;\n};\n\n/**\n * Bind state properties to UI elements\n * \n * @param {Object} state - The state object to bind.\n * @param {HTMLElement} [context=document] - The container to bind within.\n */\nAnJS.prototype.bind = function (state, context = document) {\n\n    // Bind all types: `data-bind`, `data-bind-this`, `data-bind-attr`\n    context.querySelectorAll(\"[data-bind], [data-bind-this], [data-bind-attr]\").forEach(el => {\n\n        // Skip already bound elements\n        if (el.dataset.bound) return;\n\n        // Mark element as bound\n        el.dataset.bound = \"true\";\n\n        // Extract attribute and property names\n        const [attr, prop] = el.getAttribute(\"data-bind-attr\")?.split(\":\") || [null, el.getAttribute(\"data-bind\") || el.getAttribute(\"data-bind-this\")];\n\n        // Handle nested properties (e.g., `cards.title`)\n        const parts = prop?.split(\".\");\n\n        // Retrieve the property value\n        const value = parts?.length > 1\n\n            // Nested properties (e.g., `cards.title`)\n            ? parts.slice(1).reduce((o, k) => o?.[k], globalStates[parts[0]] ?? state)\n\n            // Regular properties\n            : state[prop] ?? globalStates[prop];\n\n        // Bind `data-bind` (text updates)\n        if (el.hasAttribute(\"data-bind\")) {\n\n            // Store global bindings\n            (bindings[prop] ||= []).push(el);\n\n            // Set initial text content\n            el.textContent = value ?? \"\";\n        }\n\n        // Bind `data-bind-this` (scoped text updates)\n        else if (el.hasAttribute(\"data-bind-this\")) {\n\n            // Store local bindings\n            (localBindings.get(state)[prop] ||= []).push(el);\n\n            // Set initial text content\n            el.textContent = value ?? \"\";\n        }\n\n        // Bind `data-bind-attr` (attribute updates)\n        else {\n\n            // Store attribute bindings\n            (attrBindings[prop] ||= []).push({ el, attr });\n\n            // Set attribute value\n            boolAttrs.has(attr.toLowerCase()) ? el.toggleAttribute(attr, !!value) : el.setAttribute(attr, value ?? \"\");\n\n            // Sync input fields (`data-bind-attr=\"value:someState\"`)\n            if (attr === \"value\" && [\"INPUT\", \"TEXTAREA\"].includes(el.tagName)) el.addEventListener(\"input\", () => state[prop] = el.value);\n        }\n    });\n\n    // Auto-bind events\n    this.autoEvents(state, context);\n};\n\n/**\n * Automatically bind `[data-on]` and `[data-action]` events\n * \n * @param {Object} state - The state object.\n * @param {HTMLElement} [context=document] - The container to bind within.\n */\nAnJS.prototype.autoEvents = function (state, context = document) {\n\n    // Query all elements with `data-on` attributes\n    context.querySelectorAll(\"[data-on]\").forEach(el => {\n\n        // Extract event type and handler method name\n        const [event, method] = el.getAttribute(\"data-on\")?.split(\":\");\n\n        // Ensure the event is not already bound\n        if (!el.dataset.boundEvent && typeof state[method] === \"function\") {\n\n            // Mark the element as bound\n            el.dataset.boundEvent = \"true\";\n\n            // Define event handler\n            const handler = (e) => state[method]?.(e, state);\n\n            // Bind event listener to element\n            el.addEventListener(event, handler);\n\n            // Store reference in localBindings for proper unbinding\n            if (!localBindings.has(state)) {\n\n                // Initialize bindings storage for the state\n                localBindings.set(state, {});\n            }\n\n            // Store the event handler for removal in `unbind`\n            (localBindings.get(state)[event] ||= []).push({ el, event, handler });\n        }\n    });\n\n    // Bind `[data-action]` events\n    context.querySelectorAll(\"[data-action]\").forEach(el => {\n\n        // Extract the action name\n        let action = el.dataset.action;\n\n        // Skip if already bound\n        if (!el.dataset.boundAction) {\n\n            // Mark element as bound\n            el.dataset.boundAction = \"true\";\n\n            // Bind the action to the element\n            el.addEventListener(\"click\", e => {\n\n                // \uD83D\uDD0E Check if the action exists locally\n                if (typeof state[action] === \"function\") return state[action](e, state);\n\n                // \uD83D\uDD0E Check if it's a global state method (e.g., `cards.share`)\n                let [globalName, globalMethod] = (action || \"\").split(\".\");\n\n                // \uD83D\uDD0E Check if the global state method exists\n                if (typeof globalStates[globalName]?.[globalMethod] === \"function\") {\n\n                    // Call the global state method\n                    globalStates[globalName][globalMethod](e, globalStates[globalName]);\n                }\n            });\n        }\n    });\n};\n\n/**\n * Unbind all UI elements from a state\n * \n * @param {Object} state - The state object to unbind.\n */\nAnJS.prototype.unbind = function (state) {\n\n    // Remove all event listeners\n    Object.values(localBindings.get(state)).forEach(bindings =>\n\n        // Remove each event listener\n        bindings.forEach(({ el, event, handler }) => el.removeEventListener(event, handler))\n    );\n\n    // Clear bindings\n    [bindings, attrBindings].forEach(obj => Object.keys(state).forEach(prop => delete obj[prop]));\n\n    // Remove from local bindings\n    localBindings.delete(state);\n};\n\n\n/**\n * Create a **reactive state object** with persistence\n * \n * @param {string} name - The global state name.\n * @param {Object} initial - The initial state values.\n * @param {string} [persist] - Storage type (`\"local\"` or `\"session\"`).\n * @returns {Proxy} - The reactive proxy object.\n */\nfunction persistent(name, initial, persist) {\n\n    // Define reactive state with a Proxy\n    return new Proxy(initial, {\n\n        // Retrieve property\n        get: (target, prop) => target[prop],\n\n        // Update property & auto-save if persistence is enabled\n        set: (target, prop, value) => {\n\n            // Assign new value\n            target[prop] = value;\n\n            // Persist updated state if needed\n            if (persist) {\n\n                // Determine correct storage type\n                const storage = persist === \"session\" ? sessionStorage : localStorage;\n\n                // Save updated state\n                storage.setItem(name, JSON.stringify(target));\n            }\n\n            return true;\n        }\n    });\n}", "// Dependencies\nimport AnJS from './core.js';\n\n// Handles component registration and mounting\nconst components = {\n\n    // Registry for components\n    registry: {},\n\n    /**\n     * Start observing the DOM for dynamically added components.\n     * \n     * @returns {void}\n     */\n    observer() {\n\n        // Watch for dynamically added components\n        new MutationObserver(mutations => {\n\n            // Process each mutation\n            mutations.forEach(({ addedNodes }) => {\n\n                // Process each added node\n                addedNodes.forEach(node => {\n\n                    // Check if the node is an element and has a registered component\n                    if (node.nodeType === Node.ELEMENT_NODE && this.registry[node.tagName.toLowerCase()]) this.mount(node, node.tagName.toLowerCase());\n                });\n            });\n        \n        // Start observing the document body\n        }).observe(document.body, { childList: true, subtree: true });\n    },\n\n    /**\n     * Register a new component.\n     * \n     * @param {string} name - Component tag name.\n     * @param {Function} template - Rendering function.\n     * @param {Function | Object} [stateOrHandlers] - State function or event handlers.\n     * @param {Function} [handlers] - Optional event handlers.\n     */\n    register(name, template, stateOrHandlers, handlers) {\n\n        // Ignore empty registrations\n        if (!stateOrHandlers && !handlers) return;\n\n        // Default state\n        let state = () => $.state({});\n        let finalHandlers = () => { };\n\n        // Determine if argument is state or handlers\n        if (typeof stateOrHandlers === \"function\") {\n\n            // Try to determine if it's a state function or handlers\n            try {\n\n                // Assume it's a state function\n                state = typeof stateOrHandlers() === \"object\" ? stateOrHandlers : state;\n\n            // So hacky, but it works...\n            } catch {\n\n                // Assume it's handlers\n                finalHandlers = stateOrHandlers;\n            }\n        }\n\n        // If handlers are provided, use them\n        if (typeof handlers === \"function\") finalHandlers = handlers;\n\n        // Store component definition\n        this.registry[name.toLowerCase()] = { template, state, handlers: finalHandlers };\n\n        // Mount all existing instances\n        document.querySelectorAll(name.toLowerCase()).forEach(el => this.mount(el, name));\n    },\n\n    /**\n     * Mount a component dynamically.\n     * \n     * @param {HTMLElement} el - Element to replace.\n     * @param {string} name - Component name.\n     */\n    mount(el, name) {\n\n        // Retrieve component definition\n        const { template, state, handlers } = this.registry[name.toLowerCase()];\n\n        // Ensure the component isn't already mounted\n        if (el.dataset.__mounted) return;\n\n        // Mark the component as mounted\n        el.dataset.__mounted = \"true\";\n\n        // Extract props from attributes\n        const props = Object.fromEntries([...el.attributes].map(attr => [attr.name, attr.value]));\n\n        // Create an isolated state\n        const componentState = AnJS.prototype.state({ ...state(), ...props });\n\n        // Render and replace the component\n        const rendered = this.render(template({ state: componentState, props }), componentState);\n\n        // Replace the original element with the rendered component\n        el.replaceWith(rendered);\n\n        // Bind the component state\n        $(rendered).bind(componentState);\n\n        // Auto-mount child components\n        rendered.querySelectorAll(Object.keys(this.registry).join(\",\")).forEach(child => this.mount(child, child.tagName.toLowerCase()));\n\n        // Attach event handlers\n        this.bind(rendered, handlers, componentState);\n    },\n\n    /**\n     * Render an HTML string into a DOM element.\n     * \n     * @param {string} html - Component HTML.\n     * @param {Object} [state={}] - Optional state to bind.\n     * @returns {HTMLElement} - Rendered DOM element.\n     */\n    render(html, state = {}) {\n\n        // Create a temporary container to parse the HTML\n        const container = document.createElement(\"div\");\n\n        // Set the inner HTML and extract the first child element\n        container.innerHTML = html.trim();\n\n        // Ensure a valid element exists\n        const element = container.firstElementChild || null;\n\n        // If no element, return null gracefully\n        if (!element) return null;\n\n        // Bind state if provided\n        if (state) $(element).bind(state);\n\n        // Return the rendered element\n        return element;\n    },\n\n    /**\n     * Attach event handlers to a mounted component.\n     * \n     * @param {HTMLElement} rendered - Rendered component element.\n     * @param {Function | Object} handlers - Event handlers.\n     * @param {Object} componentState - Component state.\n     */\n    bind(rendered, handlers, componentState) {\n\n        // Directly invoke if it's a function\n        if (typeof handlers === \"function\") return handlers($(rendered), componentState);\n\n        // Otherwise, bind event handlers dynamically\n        Object.entries(handlers).forEach(([event, actions]) => {\n\n            // Attach event listener\n            $(rendered).on(event, \"[data-action]\", e => {\n\n                // Extract action name\n                const action = e.target.dataset.action;\n\n                // Execute the corresponding action\n                if (actions[action]) {\n\n                    // Execute the action\n                    actions[action](componentState, e);\n\n                    // Re-render the component\n                    $(rendered).bind(componentState);\n                }\n            });\n        });\n    }\n};\n\n// Start component observer\nfunction startObserver() {\n\n    // Start observer \n    document.readyState !== \"loading\"\n\n        // If the document is already loaded, start observing immediately\n        ? components.observer()\n\n        // Otherwise, wait for the DOMContentLoaded event\n        : document.addEventListener(\"DOMContentLoaded\", () => components.observer());\n}\n\n// Attach component registration to AnJS prototype\nAnJS.prototype.component = function (name, template, stateOrHandlers, handlers) {\n\n    // Register the component\n    components.register(name, template, stateOrHandlers, handlers);\n};\n\n// Attach `render()` explicitly to `AnJS.prototype`\nAnJS.prototype.render = components.render;\n\n// Execute observer start\nstartObserver();\n\n// Export function for testing\nexport { startObserver };\n\n// Export components\nexport default components;", "/**\n * Template Parts \u2014 Surgical DOM updates via tagged template literals\n *\n * First render: parses HTML and builds DOM. Subsequent renders: compares\n * old values to new and directly patches only changed text nodes and\n * attributes. No innerHTML, no diffing, no virtual DOM.\n */\n\n// Cache parsed templates by their static strings array (reference identity)\nconst templateCache = new WeakMap();\n\n// Sentinel for empty template parts (first render detection)\nconst EMPTY = Symbol('empty');\n\n/**\n * Represents the result of a tagged `html` template call.\n * Holds the static structure (strings) and the dynamic values.\n */\nexport class TemplateResult {\n\n    constructor(strings, values) {\n\n        // Static template fragments (immutable between renders for same call site)\n        this.strings = strings;\n\n        // Dynamic values for this render pass\n        this.values = values;\n    }\n}\n\n/**\n * Wraps a raw HTML string for DOM insertion (bypasses text-node escaping).\n * Use when interpolating pre-built HTML markup inside html`...` templates.\n */\nexport class UnsafeHTML {\n\n    constructor(value) {\n\n        // Store the raw HTML string\n        this.value = String(value ?? '');\n    }\n}\n\n/**\n * Mark a string as trusted HTML for DOM insertion inside html`...` templates.\n * Without this wrapper, strings are safely inserted as text nodes.\n *\n * @param {string} value - Raw HTML string to insert as DOM\n * @returns {UnsafeHTML}\n */\nexport function unsafeHTML(value) {\n\n    if (typeof console !== 'undefined') console.warn('[AnJS] unsafeHTML() is an escape hatch \u2014 convert this call site to use html`...` instead.');\n    return new UnsafeHTML(value);\n}\n\n/**\n * Tagged template literal \u2014 returns a TemplateResult instead of a string\n *\n * @param {TemplateStringsArray} strings - Static template parts\n * @param {...*} values - Dynamic interpolated values\n * @returns {TemplateResult}\n */\nexport function html(strings, ...values) {\n\n    // Return a trackable result object\n    return new TemplateResult(strings, values);\n}\n\n/**\n * Commit a TemplateResult into a container element.\n * First call builds DOM from scratch; subsequent calls patch only changes.\n *\n * @param {TemplateResult} result - The template result to render\n * @param {HTMLElement} container - The target DOM element\n */\nexport function render(result, container) {\n\n    // Guard: render() requires a TemplateResult \n    if (!(result instanceof TemplateResult)) {\n\n        // Developer error \u2014 render() should only be called with the result of html`...`\n        throw new TypeError(`render() expects a TemplateResult, got ${Array.isArray(result) ? 'Array' : typeof result}. Wrap with html\\`...\\` first.`);\n    }\n\n    // Retrieve or create instance data for this container\n    let instance = templateCache.get(container);\n\n    // First render \u2014 build DOM from scratch\n    if (!instance || instance.strings !== result.strings) {\n\n        // Build full HTML string for initial parse\n        const markup = result.strings.reduce((acc, str, i) =>\n            acc + str + (i < result.values.length ? markerFor(i) : \"\"), \"\");\n\n        // Parse into a template element (inert, no scripts execute)\n        const tpl = document.createElement('template');\n        tpl.innerHTML = markup;\n\n        // Walk the parsed DOM to find marker positions\n        const parts = [];\n        walkTemplate(tpl.content, parts);\n\n        // Clear container and adopt the parsed DOM\n        container.innerHTML = '';\n        container.appendChild(tpl.content.cloneNode(true));\n\n        // Resolve parts to live DOM references within the container\n        const liveParts = resolveParts(parts, container);\n\n        // Store instance data\n        instance = { strings: result.strings, parts: liveParts, values: result.values.map(() => EMPTY) };\n        templateCache.set(container, instance);\n    }\n\n    // Patch \u2014 update only parts whose values changed\n    commitValues(instance, result.values);\n}\n\n// \u2500\u2500 Internal Helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n// Unique markers injected into HTML to locate dynamic insertion points\nconst MARKER_PREFIX = '<!--anjs-';\nconst MARKER_SUFFIX = '-->';\n\n/**\n * Generate a comment marker for a value index\n */\nfunction markerFor(index) {\n\n    return `${MARKER_PREFIX}${index}${MARKER_SUFFIX}`;\n}\n\n/**\n * Walk a parsed template DOM to find all marker positions.\n * Records the path (child indices) from root to each marker.\n *\n * @param {Node} root - Template content fragment\n * @param {Array} parts - Output array of part descriptors\n * @param {number[]} path - Current path from root\n */\nfunction walkTemplate(root, parts, path = []) {\n\n    // Iterate children\n    let childIndex = 0;\n\n    for (let node = root.firstChild; node; node = node.nextSibling) {\n\n        // Comment node \u2014 check if it's a marker\n        if (node.nodeType === 8) {\n\n            const text = node.data.trim();\n\n            // Match marker pattern\n            if (text.startsWith('anjs-')) {\n\n                const index = parseInt(text.slice(5), 10);\n\n                if (!isNaN(index)) {\n\n                    // Record as a node part (text insertion point)\n                    parts.push({ type: 'node', index, path: [...path, childIndex] });\n                }\n            }\n        }\n\n        // Element node \u2014 check attributes for markers\n        else if (node.nodeType === 1) {\n\n            // Check each attribute for marker values\n            const attrs = [...node.attributes];\n            for (const attr of attrs) {\n\n                // Split attribute value on all markers to extract static/dynamic segments\n                const markerRe = /<!--anjs-(\\d+)-->/g;\n                const segments = attr.value.split(markerRe);\n\n                // segments with markers: ['prefix', '0', 'mid', '1', 'suffix']\n                // No markers \u2192 segments.length === 1 \u2192 skip\n                if (segments.length <= 1) continue;\n\n                // Extract alternating statics and value indices\n                const statics = [];\n                const indices = [];\n                for (let s = 0; s < segments.length; s++) {\n                    if (s % 2 === 0) {\n                        statics.push(segments[s]);\n                    } else {\n                        indices.push(parseInt(segments[s], 10));\n                    }\n                }\n\n                // Record each dynamic index as an attribute part sharing the same statics\n                for (let k = 0; k < indices.length; k++) {\n                    parts.push({\n                        type: 'attr',\n                        index: indices[k],\n                        path: [...path, childIndex],\n                        name: attr.name,\n                        statics,\n                        attrIndices: indices,\n                        slotIndex: k\n                    });\n                }\n\n                // Clean the markers from the attribute (leave statics joined)\n                node.setAttribute(attr.name, statics.join(''));\n            }\n\n            // Recurse into children\n            walkTemplate(node, parts, [...path, childIndex]);\n        }\n\n        childIndex++;\n    }\n}\n\n/**\n * Resolve part descriptors (paths) to live DOM node references\n *\n * @param {Array} parts - Part descriptors with paths\n * @param {HTMLElement} container - Live DOM container\n * @returns {Array} - Resolved parts with direct node references\n */\nfunction resolveParts(parts, container) {\n\n    return parts.map(part => {\n\n        // Walk the path to find the target node\n        let node = container;\n        for (const idx of part.path) {\n\n            node = node.childNodes[idx];\n            if (!node) return null;\n        }\n\n        // For node parts, replace the comment with a text node\n        if (part.type === 'node') {\n\n            const text = document.createTextNode('');\n            node.parentNode.replaceChild(text, node);\n            return { type: 'node', index: part.index, node: text };\n        }\n\n        // For attribute parts, store the element, attribute name, and statics\n        const resolved = { type: 'attr', index: part.index, node, name: part.name };\n        if (part.statics) {\n            resolved.statics = part.statics;\n            resolved.attrIndices = part.attrIndices;\n            resolved.slotIndex = part.slotIndex;\n        }\n        return resolved;\n\n    }).filter(Boolean);\n}\n\n/**\n * Commit new values to resolved parts \u2014 only updates what changed\n *\n * @param {Object} instance - Template instance (parts, old values)\n * @param {Array} newValues - New dynamic values\n */\nfunction commitValues(instance, newValues) {\n\n    for (const part of instance.parts) {\n\n        const newVal = newValues[part.index];\n        const oldVal = instance.values[part.index];\n\n        // Skip unchanged values\n        if (newVal === oldVal) continue;\n\n        if (part.type === 'node') {\n\n            // Handle nested TemplateResults\n            if (newVal instanceof TemplateResult) {\n\n                // Create a transparent container and render into it\n                if (!part._container) {\n                    part._container = document.createElement('span');\n                    part._container.style.display = 'contents';\n                    part.node.parentNode.replaceChild(part._container, part.node);\n                }\n                render(newVal, part._container);\n            }\n\n            // Handle raw HTML strings (unsafeHTML wrapper)\n            else if (newVal instanceof UnsafeHTML) {\n\n                if (!part._container) {\n                    part._container = document.createElement('span');\n                    part._container.style.display = 'contents';\n                    part.node.parentNode.replaceChild(part._container, part.node);\n                }\n                part._container.innerHTML = newVal.value;\n            }\n\n            // Handle arrays\n            else if (Array.isArray(newVal)) {\n\n                commitArray(part, newVal);\n            }\n\n            // Handle null/undefined/false \u2014 clear\n            else if (newVal == null || newVal === false) {\n\n                // Restore text node if we previously had a container (array/nested)\n                if (part._container) {\n\n                    const text = document.createTextNode('');\n                    part._container.parentNode.replaceChild(text, part._container);\n                    part.node = text;\n                    delete part._container;\n                    delete part._items;\n                } else {\n                    part.node.data = '';\n                }\n            }\n\n            // Handle primitive values \u2014 update text\n            else {\n\n                // Restore text node if we previously had a container\n                if (part._container) {\n\n                    const text = document.createTextNode(String(newVal));\n                    part._container.parentNode.replaceChild(text, part._container);\n                    part.node = text;\n                    delete part._container;\n                }\n                else {\n                    part.node.data = String(newVal);\n                }\n            }\n        }\n\n        else if (part.type === 'attr') {\n\n            // Reconstruct full attribute value from statics + all dynamic values\n            if (part.statics) {\n\n                // Build value: static[0] + val[0] + static[1] + val[1] + ... + static[n]\n                const statics = part.statics;\n                const indices = part.attrIndices;\n                let assembled = statics[0];\n                for (let k = 0; k < indices.length; k++) {\n                    const v = newValues[indices[k]];\n                    assembled += (v == null || v === false ? '' : String(v));\n                    assembled += statics[k + 1];\n                }\n                part.node.setAttribute(part.name, assembled);\n\n            /* istanbul ignore else \u2014 walkTemplate always provides statics */\n            } else {\n\n                // Legacy single-value attribute (no statics info)\n                if (newVal === true) {\n                    part.node.setAttribute(part.name, '');\n                } else if (newVal === false || newVal == null) {\n                    part.node.removeAttribute(part.name);\n                } else {\n                    part.node.setAttribute(part.name, String(newVal));\n                }\n            }\n        }\n    }\n\n    // Store current values for next diff\n    instance.values = [...newValues];\n}\n\n/**\n * Handle array values \u2014 render each item, add/remove as needed\n *\n * @param {Object} part - The node part\n * @param {Array} items - Array of values (strings or TemplateResults)\n */\nfunction commitArray(part, items) {\n\n    // Initialize array tracking on first use\n    if (!part._items) {\n\n        part._items = [];\n\n        // Replace text node with a container\n        if (!part._container) {\n            part._container = document.createElement('span');\n            part._container.style.display = 'contents';\n            part.node.parentNode.replaceChild(part._container, part.node);\n        }\n    }\n\n    const container = part._container;\n    const existing = part._items;\n\n    // Update existing items and append new ones\n    for (let i = 0; i < items.length; i++) {\n\n        const item = items[i];\n\n        if (i < existing.length) {\n\n            // Update existing slot\n            if (item instanceof TemplateResult) {\n                render(item, existing[i]);\n            } else {\n                existing[i].textContent = String(item ?? '');\n            }\n        } else {\n\n            // Create new slot\n            const slot = document.createElement('span');\n            slot.style.display = 'contents';\n\n            if (item instanceof TemplateResult) {\n                render(item, slot);\n            } else {\n                slot.textContent = String(item ?? '');\n            }\n\n            container.appendChild(slot);\n            existing.push(slot);\n        }\n    }\n\n    // Remove excess items\n    while (existing.length > items.length) {\n\n        const removed = existing.pop();\n        removed.remove();\n    }\n}\n\n/**\n * Flush template cache for a container (used during teardown)\n *\n * @param {HTMLElement} container\n */\nexport function clearTemplate(container) {\n\n    templateCache.delete(container);\n}\n", "/**\n * DOM Morph \u2014 Lightweight recursive DOM patcher\n *\n * Reconciles an existing DOM tree with new HTML by walking both trees\n * in parallel. Matching nodes are patched in-place (preserving focus,\n * scroll, event listeners). Mismatched nodes are replaced. New nodes\n * are appended, excess nodes are removed.\n *\n * No keyed reordering \u2014 relies on structurally stable templates\n * (same tag order between renders). This keeps it under 60 lines.\n */\n\n/**\n * Morph the contents of `target` to match `newHTML`\n *\n * @param {HTMLElement} target - Live DOM element to patch\n * @param {string} newHTML - Desired HTML content\n */\nexport function morph(target, newHTML) {\n\n    // Parse new HTML into a temporary container\n    const template = document.createElement('template');\n    template.innerHTML = newHTML;\n\n    // Reconcile children of target against parsed children\n    reconcile(target, target.childNodes, template.content.childNodes);\n}\n\n/**\n * Recursively reconcile two sets of child nodes\n *\n * @param {Node} parent - Parent node in the live DOM\n * @param {NodeList} oldNodes - Current live children\n * @param {NodeList} newNodes - Desired children (from parsed HTML)\n */\nfunction reconcile(parent, oldNodes, newNodes) {\n\n    const newLen = newNodes.length;\n\n    // Patch existing nodes in parallel\n    for (let i = 0; i < newLen; i++) {\n\n        const oldChild = oldNodes[i];\n        const newChild = newNodes[i];\n\n        // Append new node (didn't exist before)\n        if (!oldChild) {\n\n            parent.appendChild(newChild.cloneNode(true));\n            continue;\n        }\n\n        // Same node type \u2014 patch in place\n        if (oldChild.nodeType === newChild.nodeType) {\n\n            // Text or comment node \u2014 update data if different\n            if (oldChild.nodeType === 3 || oldChild.nodeType === 8) {\n\n                if (oldChild.data !== newChild.data) {\n                    oldChild.data = newChild.data;\n                }\n                continue;\n            }\n\n            // Element node \u2014 same tag: sync attributes and recurse\n            if (oldChild.nodeType === 1 && oldChild.tagName === newChild.tagName) {\n\n                syncAttributes(oldChild, newChild);\n                reconcile(oldChild, oldChild.childNodes, newChild.childNodes);\n                continue;\n            }\n        }\n\n        // Type or tag mismatch \u2014 replace entirely\n        parent.replaceChild(newChild.cloneNode(true), oldChild);\n    }\n\n    // Remove excess old nodes (iterate backwards to avoid index shifts)\n    while (parent.childNodes.length > newLen) {\n\n        parent.removeChild(parent.lastChild);\n    }\n}\n\n/**\n * Sync attributes from a fresh element onto an existing element\n *\n * @param {HTMLElement} oldEl - Live DOM element to update\n * @param {HTMLElement} newEl - Parsed element with desired attributes\n */\nfunction syncAttributes(oldEl, newEl) {\n\n    // Set or update new attributes\n    for (const { name, value } of newEl.attributes) {\n\n        if (oldEl.getAttribute(name) !== value) {\n\n            oldEl.setAttribute(name, value);\n        }\n    }\n\n    // Remove stale attributes\n    for (const { name } of [...oldEl.attributes]) {\n\n        if (!newEl.hasAttribute(name)) {\n\n            oldEl.removeAttribute(name);\n        }\n    }\n\n    // Sync special properties that don't reflect to attributes\n    const tag = oldEl.tagName;\n    const isFocused = document.activeElement === oldEl;\n\n    if (tag === 'INPUT' || tag === 'TEXTAREA') {\n\n        // Sync value property (doesn't reflect from setAttribute)\n        /* istanbul ignore next \u2014 isFocused skip verified by mock tests; JSDOM sub-branch limitation */\n        if (oldEl.value !== newEl.value && !isFocused) {\n            oldEl.value = newEl.value || '';\n        }\n\n        // Sync checked property for checkboxes and radio buttons\n        if (oldEl.type === 'checkbox' || oldEl.type === 'radio') {\n            if (oldEl.checked !== newEl.checked && !isFocused) {\n                oldEl.checked = newEl.checked;\n            }\n        }\n    }\n\n    // Sync SELECT value (selectedIndex doesn't reflect from parsing)\n    /* istanbul ignore next \u2014 isFocused skip verified by mock tests; JSDOM sub-branch limitation */\n    if (tag === 'SELECT' && !isFocused) {\n        if (oldEl.value !== newEl.value) {\n            oldEl.value = newEl.value;\n        }\n    }\n}\n", "// Template Parts \u2014 Surgical DOM updates via tagged template literals\nimport { html, unsafeHTML, UnsafeHTML, TemplateResult, render as commitTemplate, clearTemplate } from './template.js';\n\n// DOM Morph \u2014 Lightweight recursive DOM patcher\nimport { morph } from './morph.js';\n\n// Re-export html and unsafeHTML for consumer use\nexport { html, unsafeHTML };\n\n// Utility: Register components\nexport const registerComponent = (name, ComponentClass) => {\n\n    // Define the component only if not already registered\n    if (!customElements.get(name)) customElements.define(name, ComponentClass);\n};\n\n// Base Class for AnJS Elements\nexport class AnJSElement extends HTMLElement {\n\n    // Define which attributes to observe (subclasses should override this)\n    static get observedAttributes() {\n\n        // Default to an empty array\n        return [];\n    }\n\n    // Constructor initializes state\n    constructor() {\n\n        // Call parent constructor\n        super();\n\n        // Track whether a microtask update is pending\n        this._updatePending = false;\n\n        // Track whether first render has occurred\n        this._initialized = false;\n\n        // Computed property definitions \u2014 Map<name, { deps, fn }>\n        this._computedDefs = new Map();\n\n        // Create reactive state with auto-update on change\n        this.state = new Proxy($.state({}), {\n\n            // Intercept property changes\n            set: (target, prop, value) => {\n\n                // Assign new value\n                target[prop] = value;\n\n                // Recalculate computed properties that depend on this property\n                this._recompute(prop);\n\n                // Queue a batched update (coalesces multiple sets into one render)\n                if (!this._updatePending) {\n                    this._updatePending = true;\n                    queueMicrotask(() => {\n                        if (this._updatePending) {\n                            this._updatePending = false;\n                            this.update();\n                        }\n                    });\n                }\n\n                // Confirm change\n                return true;\n            }\n        });\n    }\n\n    // Lifecycle: Called when element is added to the DOM\n    connectedCallback() {\n\n        // Initialize state from attributes\n        this.constructor.observedAttributes.forEach(attr => {\n\n            // Assign attribute values to state (batched \u2014 only one render at end)\n            this.state[attr] = this.getAttribute(attr) ?? \"\";\n        });\n\n        // Ensure UI updates immediately (cancels any pending microtask)\n        this.update();\n    }\n\n    // Lifecycle: Called when element is removed from the DOM\n    disconnectedCallback() {\n\n        // Cancel any pending microtask render (element is detached)\n        this._updatePending = false;\n    }\n\n    // Lifecycle: Called when an observed attribute changes\n    attributeChangedCallback(name, oldValue, newValue) {\n\n        // Update state when attributes change (proxy handles the render)\n        if (this.state[name] !== newValue) {\n\n            // Assign new value \u2014 proxy set trap queues batched update\n            this.state[name] = newValue;\n        }\n    }\n\n    /**\n     * Define a computed property that auto-recalculates when dependencies change\n     *\n     * @param {string} name - Computed property name (set on this.state)\n     * @param {string[]} deps - Array of state property names to watch\n     * @param {Function} fn - Compute function, receives dependency values as arguments\n     */\n    computed(name, deps, fn) {\n\n        // Store the definition\n        this._computedDefs.set(name, { deps, fn });\n\n        // Calculate initial value\n        const values = deps.map(d => this.state[d]);\n        this.state[name] = fn(...values);\n    }\n\n    /**\n     * Recalculate computed properties when a dependency changes\n     *\n     * @param {string} changedProp - The property that just changed\n     * @private\n     */\n    _recompute(changedProp) {\n\n        // Skip if already inside a recomputation (prevent infinite loops)\n        if (this._computing) return;\n\n        for (const [name, { deps, fn }] of this._computedDefs) {\n\n            // Only recompute if the changed property is a dependency\n            if (deps.includes(changedProp)) {\n\n                const values = deps.map(d => this.state[d]);\n                const newVal = fn(...values);\n\n                // Only update if value actually changed\n                if (this.state[name] !== newVal) {\n\n                    this._computing = true;\n                    this.state[name] = newVal;\n                    this._computing = false;\n                }\n            }\n        }\n    }\n\n    // Update DOM based on the current state\n    update() {\n\n        // Cancel any pending microtask render (explicit update wins)\n        this._updatePending = false;\n\n        // Get the render result\n        const result = this.render();\n\n        // Template parts \u2014 surgical updates (preferred path)\n        if (result instanceof TemplateResult) {\n\n            commitTemplate(result, this);\n        }\n\n        // String result with existing DOM \u2014 morph (patch in place)\n        else if (typeof result === 'string' && this._initialized) {\n\n            morph(this, result);\n        }\n\n        // String result, first render \u2014 innerHTML (fast bootstrap)\n        else if (typeof result === 'string') {\n\n            this.innerHTML = result;\n        }\n\n        // Mark as initialized after first render\n        this._initialized = true;\n\n        // Bind state updates to the UI\n        $.bind(this.state, this);\n    }\n\n    // Default render method (override in subclasses)\n    render() {\n\n        // Placeholder message for unimplemented components\n        return `<p>${this.constructor.name} is not implemented yet.</p>`;\n    }\n}", "// Dependencies\nimport AnJS from './core.js';\n\n/**\n * Merge and normalize request headers\n * \n * @param {Object} customHeaders - Headers from options.\n * @param {boolean} hasBody - Whether the request includes a body.\n * @returns {Object} - Merged headers with defaults.\n */\nfunction mergeHeaders(customHeaders = {}, hasBody) {\n\n    // Default headers\n    const headers = {\n        'Accept': 'application/json',\n        ...customHeaders\n    };\n\n    // Ensure JSON requests explicitly set Content-Type\n    if (hasBody && !headers['Content-Type']) headers['Content-Type'] = 'application/json';\n\n    // Return merged headers\n    return headers;\n}\n\n/**\n * Process request body based on Content-Type\n * \n * @param {Object | FormData | string | null} data - Request body.\n * @param {Object} headers - Headers to determine encoding.\n * @returns {string | FormData | URLSearchParams | undefined} - Encoded body.\n */\nfunction processBody(data, headers) {\n\n    // FormData (auto-sets headers)\n    if (data instanceof FormData) {\n\n        // Ensure Content-Type is removed (let browser handle it)\n        delete headers['Content-Type'];\n\n        // Return FormData object\n        return data;\n    }\n\n    // Detect form-encoded body\n    const isFormEncoded = headers['Content-Type'] === 'application/x-www-form-urlencoded';\n\n    // Convert to URL-encoded form data\n    return isFormEncoded ? new URLSearchParams(data).toString() : JSON.stringify(data);\n}\n\n/**\n * Handle request timeout using Promise.race\n * \n * @param {Promise} fetchPromise - The fetch request promise.\n * @param {number} timeout - Timeout duration in milliseconds.\n * @param {string} url - Request URL for error reporting.\n * @returns {Promise} - Fetch promise with timeout logic.\n */\nfunction withTimeout(fetchPromise, timeout, url) {\n\n    // No timeout\n    if (timeout === 0 || timeout == null) return fetchPromise;\n\n    // Race against timeout\n    return Promise.race([\n\n        // Fetch promise\n        fetchPromise,\n\n        // Timeout promise\n        new Promise((_, reject) =>\n\n            // Reject with timeout error\n            setTimeout(() => reject(new Error(`Request timed out: ${url}`)), timeout)\n        )\n    ]);\n}\n\n/**\n * Perform an HTTP request using fetch\n * \n * @param {string} url - The request URL.\n * @param {string} method - The HTTP method.\n * @param {Object | FormData | string | null} data - Request body.\n * @param {Object} options - Additional fetch options.\n * @returns {Promise} - Resolves with JSON or text response.\n * @throws {Error} - Rejects on network or response errors.\n */\nexport function request(url, method = 'GET', data = null, options = {}) {\n\n    // Request timeout & signal\n    const { timeout = 5000, signal } = options;\n\n    // Construct absolute URL\n    const urlObj = new URL(url, window.location.origin);\n\n    // Determine if request has a body\n    const hasBody = data && !['GET', 'DELETE'].includes(method);\n\n    // Merge headers\n    const headers = mergeHeaders(options.headers, hasBody);\n\n    // Process request body\n    const body = hasBody ? processBody(data, headers) : undefined;\n\n    // Fetch options\n    const fetchOptions = { method, headers, ...(body && { body }), ...(signal && { signal }) };\n\n    // Execute fetch request\n    const fetchPromise = fetch(urlObj.toString(), fetchOptions).then(response => {\n\n        // Throw error if response is not OK\n        if (!response.ok) throw new Error(`HTTP ${response.status} at ${url}`);\n\n        // Ensure headers exist before accessing them\n        const contentType = response.headers?.get('Content-Type') || '';\n\n        // Return JSON if applicable, otherwise return as text\n        return contentType.includes('application/json') ? response.json() : response.text();\n    });\n\n    // Handle timeout\n    return withTimeout(fetchPromise, timeout, url);\n}\n\n/**\n * Attach request function to `AnJS.prototype`\n */\nAnJS.prototype.request = function (url, method = 'GET', data = null, options = {}) {\n\n    // Delegate to request function\n    return request(url, method, data, options);\n};\n\n/**\n * Define HTTP method shortcuts\n */\nexport const http = {\n\n    // Read operations (safe, idempotent)\n    head: (url, options = {}) => request(url, \"HEAD\", null, options),\n    get: (url, options = {}) => request(url, 'GET', null, options),\n    options: (url, options = {}) => request(url, \"OPTIONS\", null, options),\n\n    // Write operations (modifying data)\n    post: (url, data, options = {}) => request(url, 'POST', data, options),\n    put: (url, data, options = {}) => request(url, 'PUT', data, options),\n    patch: (url, data, options = {}) => request(url, 'PATCH', data, options),\n    delete: (url, options = {}) => request(url, 'DELETE', null, options),\n\n    // Utilities\n    abortController: () => new AbortController(),\n};\n\n// Export module\nexport default http;", "// Dependencies\nimport AnJS from './core.js';\n\n// Batch assign animation methods to AnJS prototype\nObject.assign(AnJS.prototype, {\n\n    /**\n     * Animate elements with CSS transitions.\n     * \n     * @param {Object} styles - CSS properties to animate.\n     * @param {number} [duration=400] - Duration in milliseconds.\n     * @param {string} [easing=\"ease\"] - Easing function.\n     * @returns {AnJS} - The current AnJS instance for chaining.\n     */\n    animate(styles, duration = 400, easing = \"ease\") {\n\n        // Apply animation\n        return this.each(el => {\n\n            // Set transition effect\n            el.style.transition = `all ${duration}ms ${easing}`;\n\n            // Apply new styles\n            Object.assign(el.style, styles);\n\n            // Reset transition after duration if styles changed\n            if (duration > 0) setTimeout(() => el.style.transition = \"\", duration);\n        });\n    },\n\n    /**\n     * Fade elements to a specific opacity.\n     * \n     * @param {number} [opacity] - Target opacity (0 to 1).\n     * @param {number} [duration=400] - Duration in milliseconds.\n     * @returns {AnJS} - The current AnJS instance for chaining.\n     */\n    fade(opacity = +(this[0]?.style.opacity === \"0\"), duration = 400) {\n\n        // Animate opacity change\n        return this.animate({ opacity }, duration);\n    },\n\n    /**\n     * Fade elements in or out.\n     * \n     * @param {number} [duration=400] - Duration in milliseconds.\n     * @return {AnJS} - The current AnJS instance for chaining.\n     */\n    fadeIn(duration) { \n        \n        // Convenience wrapper\n        return this.fade(1, duration); \n    },\n\n    /**\n     * Fade elements out.\n     * \n     * @param {number} [duration=400] - Duration in milliseconds.\n     * @return {AnJS} - The current AnJS instance for chaining.\n     */\n    fadeOut(duration) { \n        \n        // Convenience wrapper\n        return this.fade(0, duration); \n    }\n});", "// Ensure feature flags exist at runtime\nif (typeof FEATURE_HTTP === \"undefined\") globalThis.FEATURE_HTTP = true;\nif (typeof FEATURE_ANIMATE === \"undefined\") globalThis.FEATURE_ANIMATE = true;\nif (typeof FEATURE_SELECTION === \"undefined\") globalThis.FEATURE_SELECTION = true;\nif (typeof FEATURE_FILTERING === \"undefined\") globalThis.FEATURE_FILTERING = true;\nif (typeof FEATURE_TRAVERSAL === \"undefined\") globalThis.FEATURE_TRAVERSAL = true;\nif (typeof FEATURE_STATE === \"undefined\") globalThis.FEATURE_STATE = true;\nif (typeof FEATURE_COMPONENTS === \"undefined\") globalThis.FEATURE_COMPONENTS = true;\nif (typeof FEATURE_ELEMENTS === \"undefined\") globalThis.FEATURE_ELEMENTS = true;\n\n// Dependencies\nimport AnJS from './core.js';\n\n// Modules\nimport './dom.js';\nimport './attributes.js';\nimport './events.js';\nimport './alias.js';\n\n// Utilities\nimport utils from './utilities.js';\nimport extend from './extend.js';\n\n// AnJS Events System\nimport { bus } from './events.js';\n\n/**\n * Factory function for creating AnJS instances\n * \n * @param {string | HTMLElement} selector - CSS selector or element.\n * @returns {AnJS} - AnJS instance.\n */\nfunction $(selector) {\n\n    // New instance of AnJS\n    return new AnJS(selector);\n}\n\n// AnJS methods that should be accessible via `$`\n[\"on\", \"off\", \"trigger\"].forEach(method => {\n\n    // Dynamically assign methods to `$`\n    $[method] = (...args) => AnJS.prototype[method].apply($(), args);\n});\n\n/**\n * Dynamic Imports (Only Load If Enabled)\n * \n * @constant {boolean} FEATURE_SELECTION - Feature flag for selection module.\n * @constant {boolean} FEATURE_STATE - Feature flag for state module.\n * @constant {boolean} FEATURE_COMPONENTS - Feature flag for components module.\n * @constant {boolean} FEATURE_ELEMENTS - Feature flag for elements module.\n * @constant {boolean} FEATURE_HTTP - Feature flag for HTTP module.\n * @constant {boolean} FEATURE_ANIMATE - Feature flag for animate module.\n * @constant {boolean} FEATURE_FILTERING - Feature flag for filtering module.\n * @constant {boolean} FEATURE_TRAVERSAL - Feature flag for traversal module.\n */\n\n// Feature flag: Selection\nif (FEATURE_SELECTION) {\n\n    // Dynamic import of filtering\n    import('./filtering.js').then(mod => Object.assign($, mod));\n\n    // Dynamic import of traversal\n    import('./traversal.js').then(mod => Object.assign($, mod));\n}\n\n// Dynamically import \"State\" module\nif (FEATURE_STATE) import('./state.js').then(() => { \n    \n    /// Attach state functions dynamically\n    [\"state\", \"global\"].forEach(module => {\n\n        // Dynamically assign methods to `$`\n        $[module] = (...args) => AnJS.prototype[module].apply($(), args);\n    });\n});\n\n// Dynamically import \"Component\" module\nif (FEATURE_COMPONENTS) {\n\n    // Perform the file import\n    import('./component.js').then(mod => {\n\n        // Attach component methods dynamically\n        [\"component\"].forEach(module => {\n\n            // Dynamically assign methods to `$`\n            $[module] = (...args) => AnJS.prototype[module].apply($(), args);\n        });\n\n        // Attach $.define only if the module is loaded\n        $.define = (name, componentClass) => customElements.define(name, componentClass);\n    });\n}\n\n// Dynamically import \"Element\" module (includes template parts + morph)\nif (FEATURE_ELEMENTS) import('./element.js');\n\n// Dynamically import \"HTTP\" module\nif (FEATURE_HTTP) import ('./request.js').then(mod => {\n\n    // Attach HTTP utilities\n    Object.assign($, mod.http);  \n});\n\n// Dynamically import \"Animate\" module\nif (FEATURE_ANIMATE) import('./animate.js');\n\n// Attach utilities to `$`\nObject.assign($, bus, utils, extend);\n\n// Define custom element\n$[\"define\"] = (name, componentClass) => customElements.define(name, componentClass);\n\n// Attach to `window` if in browser\nif (typeof window !== \"undefined\") window.$ = $;\n\n// Export module\nexport default $;\n\n// Named export\nexport { $ };", "// Dependencies\nimport AnJS from './core.js';\n\n// Batch assign methods to AnJS prototype\nObject.assign(AnJS.prototype, {\n\n    /**\n     * Get or set text or HTML content\n     * \n     * @param {string} [value] - Content to set.\n     * @param {boolean} [html=false] - Whether to set/get as HTML (true) or text (false).\n     * @returns {string | AnJS} - Content if getting, or self for chaining if setting.\n     */\n    content(value, html = false) {\n\n        // Get content\n        if (value === undefined) {\n\n            // Return empty string if no elements exist\n            if (!this[0]) return '';\n\n            // Return HTML or text content\n            return html ? this[0].innerHTML : this[0].textContent;\n        }\n\n        // Set content\n        return this.each(el => html ? (el.innerHTML = value) : (el.textContent = value));\n    },\n\n    /**\n     * Get or set text content\n     * \n     * @param {string} [value] - Text content to set.\n     * @return {string | AnJS} - Text content if getting, or self for chaining if setting.\n     */\n    text(value) { \n        \n        // Convenience wrapper\n        return this.content(value, false); \n    },\n    \n    /**\n     * Get or set HTML content\n     * \n     * @param {string} [value] - HTML content to set.\n     * @return {string | AnJS} - HTML content if getting, or self for chaining if setting.\n     */\n    html(value) { \n       \n        // Convenience wrapper\n        return this.content(value, true); \n    },\n\n    /**\n     * Get or set CSS styles\n     * \n     * @param {string} name - CSS property name.\n     * @param {string} [value] - CSS value to set.\n     * @returns {string | AnJS} - CSS value if getting, or self for chaining if setting.\n     */\n    css(name, value) {\n\n        // Get computed CSS value\n        if (value === undefined) return this[0]?.style.getPropertyValue(name) || '';\n\n        // Set CSS value\n        return this.each(el => el.style[name] = value);\n    },\n\n    /**\n     * Add, remove, or toggle a class\n     * \n     * @param {string} name - Class name.\n     * @param {boolean} [add] - Add (true), Remove (false), Toggle (undefined).\n     * @returns {AnJS} - Self for chaining.\n     */\n    class(name, add) {\n\n        // Add, remove, or toggle class\n        return this.each(el => el.classList[add === undefined ? 'toggle' : add ? 'add' : 'remove'](name));\n    },\n\n    /**\n     * Show or hide elements\n     * \n     * @param {boolean} show - Show (true), Hide (false).\n     * @returns {AnJS} - Self for chaining.\n     */\n    display(show) {\n\n        // Show or hide elements\n        return this.each(el => el.style.display = show ? '' : 'none');\n    },\n\n    /**\n     * Show or hide elements\n     * \n     * @returns {AnJS} - Self for chaining.\n     */\n    hide() { \n        \n        // Hide elements\n        return this.display(false); \n    },\n\n    /**\n     * Show elements\n     * \n     * @returns {AnJS} - Self for chaining.\n     */\n    show() { \n        \n        // Show elements\n        return this.display(true); \n    },\n\n    /**\n     * Remove elements from the DOM\n     * \n     * @returns {AnJS} - Self for chaining.\n     */\n    remove() {\n\n        // Remove elements\n        return this.each(el => el.remove());\n    },\n\n    /**\n     * Empty elements (remove all children)\n     * \n     * @returns {AnJS} - Self for chaining.\n     */\n    empty() {\n\n        // Empty elements // TODO: Clear input, textarea, select, etc. ..?\n        return this.each(el => el.innerHTML = '');\n    },\n\n    /**\n     * Insert content relative to the selected element(s)\n     *\n     * @param {string | HTMLElement | HTMLElement[]} content - HTML string, element, or array of elements.\n     * @param {string} position - 'before', 'prepend', 'append', 'after'.\n     * @returns {AnJS} - Chainable instance.\n     */\n    insert(content, position = 'before') {\n\n        // Allowed positions\n        const positions = { before: 'beforeBegin', prepend: 'afterBegin', append: 'beforeEnd', after: 'afterEnd' };\n\n        // Validate position\n        if (!positions[position]) return this;\n\n        // Insert content at specified position\n        return this.each(target => {\n\n            // Insert HTML string\n            if (typeof content === 'string') return target.insertAdjacentHTML(positions[position], content);\n\n            // Insert element(s)\n            (Array.isArray(content) ? content : [content]).forEach(el =>\n\n                // Insert element at specified position\n                target.insertAdjacentElement(positions[position], el.cloneNode(true))\n            );\n        });\n    },\n\n    /**\n     * Get or set a property\n     *\n     * @param {string} name - Property name.\n     * @param {any} value - Property value (optional).\n     * @returns {any | AnJS} - Property value if getting, or self for chaining if setting.\n     */\n    prop(name, value) {\n\n        // Get property value if no second argument is provided\n        if (arguments.length === 1) return this[0]?.[name];\n\n        // Set property value\n        return this.each(el => el[name] = value);\n    },\n\n    /**\n     * Get or set the value of form elements\n     * \n     * @param {string} [value] - The value to set (if provided).\n     * @returns {string | AnJS} - The current value if getting, or the AnJS instance if setting.\n     */\n    val(value) {\n\n        // Get value if no argument is passed\n        if (arguments.length === 0) return this[0]?.value;\n\n        // Set value\n        return this.each(el => el.value = value);\n    },\n\n    /**\n     * Check if the first selected element has a class\n     * \n     * @param {string} className - Class name.\n     * @returns {boolean} - True if the class exists, otherwise false.\n     */\n    has(className) {\n\n        // Check if the first element has the class\n        return this[0]?.classList.contains(className) ?? false;\n    },\n\n    /**\n     * Focus on the first selected element\n     * \n     * @returns {AnJS} - Self for chaining.\n     */\n    focus() {\n\n        // Focus on the first element\n        this[0]?.focus();\n\n        // Return self for chaining\n        return this;\n    },\n\n    /**\n     * Remove focus from the first selected element\n     * \n     * @returns {AnJS} - Self for chaining.\n     */\n    blur() {\n\n        // Remove focus from the first element\n        this[0]?.blur();\n\n        // Return self for chaining\n        return this;\n    }\n});", "// Dependencies\nimport AnJS from './core.js';\n\n// Batch assign attribute methods to AnJS prototype\nObject.assign(AnJS.prototype, {\n\n    /**\n     * Get or set an attribute on selected elements\n     * \n     * @param {string} name - Attribute name.\n     * @param {string} [value] - Attribute value (if setting).\n     * @returns {string | AnJS} - Attribute value if getting, AnJS instance if setting.\n     */\n    attr(name, value) {\n\n        // Get attribute\n        if (value === undefined) return this[0]?.getAttribute(name);\n\n        // Remove attribute if value is null\n        if (value === null) return this.each(el => el.removeAttribute(name));\n\n        // Set attribute\n        return this.each(el => el.setAttribute(name, value));\n    },\n\n    /**\n     * Get or set the id attribute\n     * \n     * @param {string} [value] - The id to set.\n     * @returns {string | AnJS} - The id if getting, otherwise chainable.\n     */\n    id(value) {\n\n        // Get or set id attribute\n        return value === undefined ? this.attr(\"id\") : this.attr(\"id\", value);\n    },\n\n    /**\n     * Remove an attribute from selected elements\n     * \n     * @param {string} name - Attribute name to remove.\n     * @returns {AnJS} - Returns self for chaining.\n     */\n    removeAttr(name) {\n\n        // Remove attribute\n        return this.attr(name, null);\n    },\n\n    /**\n     * Serialize form data from the first selected element\n     * \n     * @returns {string} - URL-encoded form data string or an empty string if not a form.\n     */\n    serialize() {\n\n        // Ensure the selected element is a form before serializing\n        return this[0] instanceof HTMLFormElement ? new URLSearchParams(new FormData(this[0])).toString() : '';\n    }\n});", "// Dependencies\nimport AnJS from './core.js';\n\n// WeakMap to store event handlers per element\nconst eventStore = new WeakMap();\n\n// Batch assign event handling methods to AnJS prototype\nObject.assign(AnJS.prototype, {\n\n    /**\n     * Attach an event listener (direct or delegated)\n     * \n     * @param {string} event - Event type (e.g., 'click')\n     * @param {string | Function} selector - Selector for delegation or event handler\n     * @param {Function} [handler] - Event handler if delegation is used\n     * @returns {AnJS} - Chainable instance\n     */\n    on(event, selector, handler) {\n\n        // If no selector is provided, attach directly\n        return typeof selector === \"function\"\n\n            // Attach directly\n            ? this.delegate(event, null, selector)\n\n            // Attach with delegation\n            : this.delegate(event, selector, handler);\n    },\n\n    /**\n     * Remove an event listener (direct or delegated)\n     * \n     * @param {string} event - Event type (e.g., 'click')\n     * @param {string | Function} selector - Selector for delegation or event handler\n     * @param {Function} [handler] - Event handler if delegation is used\n     * @returns {AnJS} - Chainable instance\n     */\n    off(event, selector, handler) {\n\n        // If no selector is provided, remove directly\n        return typeof selector === \"function\"\n\n            // Remove directly\n            ? this.undelegate(event, null, selector)\n\n            // Remove with delegation\n            : this.undelegate(event, selector, handler);\n    },\n\n    /**\n     * Attach a delegated event listener using WeakMap for storage\n     * \n     * @param {string} event - Event type (e.g., 'click')\n     * @param {string | null} selector - Selector to match (e.g., '.btn') or `null` for direct binding\n     * @param {Function} handler - Event callback function\n     * @returns {AnJS} - Chainable instance\n     */\n    delegate(event, selector, handler) {\n\n        // Iterate over each element\n        return this.each(el => {\n\n            // Retrieve or initialize event storage for the element\n            if (!eventStore.has(el)) eventStore.set(el, {});\n\n            // Retrieve the event storage\n            const events = eventStore.get(el);\n\n            // Ensure event storage exists for the given type\n            if (!events[event]) events[event] = [];\n\n            // Create a wrapper function for delegation\n            const delegateHandler = e => {\n\n                // Find the closest matching element\n                const target = selector ? e.target.closest(selector) : el;\n\n                // If a match is found, call the handler\n                if (target && el.contains(target)) handler.call(target, e);\n            };\n\n            // Store multiple handlers per selector-event combination\n            events[event].push({ selector, handler, delegateHandler });\n\n            // Attach event listener\n            el.addEventListener(event, delegateHandler);\n        });\n    },\n\n    /**\n     * Remove a delegated event listener using WeakMap\n     * \n     * @param {string} event - Event type (e.g., 'click')\n     * @param {string | null} selector - Selector for delegation or `null` for direct binding\n     * @param {Function} [handler] - Specific handler to remove (optional)\n     * @returns {AnJS} - Chainable instance\n     */\n    undelegate(event, selector, handler) {\n\n        // Iterate over each element\n        return this.each(el => {\n\n            // If no event store exists, return early\n            if (!eventStore.has(el)) return;\n\n            // Retrieve the event storage\n            const events = eventStore.get(el);\n\n            // If no handlers exist for this event, return early\n            if (!events[event]) return;\n\n            // Non-specific handler removal\n            if (!handler) {\n\n                // Remove all event listeners for this event\n                events[event].forEach(item => el.removeEventListener(event, item.delegateHandler));\n\n                // Delete the event entry from events\n                delete events[event];\n\n                // Specific handler removal\n            } else {\n\n                // Remove only matching handlers\n                events[event] = events[event].filter(item => {\n\n                    // If the selector and handler match, remove the event listener\n                    if (item.selector === selector && item.handler === handler) {\n\n                        // Remove the event listener\n                        el.removeEventListener(event, item.delegateHandler);\n\n                        // Filter the removed handler\n                        return false;\n                    }\n\n                    // Keep the handler\n                    return true;\n                });\n\n                // If no handlers remain for this event, remove it\n                if (events[event].length === 0) delete events[event];\n            }\n\n            // If no events remain, remove the element from the store\n            if (Object.keys(events).length === 0) eventStore.delete(el);\n        });\n    },\n\n    /**\n     * Trigger a custom event on elements\n     * \n     * @param {string} event - Event type to trigger (e.g., 'click')\n     * @returns {AnJS} - Chainable instance\n     */\n    trigger(event) {\n\n        // Trigger the event on each element\n        return this.each(el => el.dispatchEvent(new Event(event, { bubbles: true })));\n    },\n});\n\n// Object to store global event bus handlers\nconst eventBus = {};\n\n// Event Bus API\nexport const bus = {\n    /**\n     * Emit a global event\n     * \n     * @param {string} event - The event name\n     * @param {any} [data] - Optional data to send\n     */\n    emit(event, data) {\n\n        // If the event exists, call each handler\n        eventBus[event]?.forEach(handler => handler(data));\n    },\n\n    /**\n     * Listen for a global event\n     * \n     * @param {string} event - The event name\n     * @param {Function} handler - The callback function\n     */\n    listen(event, handler) {\n\n        // If the event doesn't exist, create it\n        if (!eventBus[event]) eventBus[event] = [];\n\n        // Add the handler to the event\n        eventBus[event].push(handler);\n    },\n\n    /**\n     * Remove a global event listener\n     * \n     * @param {string} event - The event name\n     * @param {Function} handler - The callback function to remove\n     */\n    forget(event, handler) {\n\n        // If the event exists\n        if (eventBus[event]) {\n\n            // Remove the handler from the event\n            eventBus[event] = eventBus[event].filter(h => h !== handler);\n\n            // If no handlers remain, delete the event\n            if (eventBus[event].length === 0) delete eventBus[event];\n        }\n    }\n};", "// Dependencies\nimport AnJS from './core.js';\n\n// Create alias methods for insertion\n[\"append\", \"prepend\", \"before\", \"after\"].forEach(method =>\n\n    // Create alias method\n    AnJS.prototype[method] = function (content) {\n\n        // Insert content at specified position\n        return this.insert(content, method);\n    }\n);\n\n// Create alias methods for event binding and triggering\n[\"click\", \"change\", \"submit\", \"keydown\", \"keyup\", \"mouseover\", \"mouseout\"].forEach(event => {\n\n    // Create alias method\n    AnJS.prototype[event] = function (callback) {\n\n        // Bind event if a callback is provided\n        return callback ? this.on(event, callback) : this.trigger(event);\n    };\n});", "/**\n * Trim a string\n * \n * @param {string} string - String to trim.\n * @returns {string} - Trimmed string.\n */\nconst trim = string => string.trim();\n\n/**\n * Parse JSON safely\n * \n * @param {string} string - JSON string.\n * @returns {Object} - Parsed JSON.\n */\nconst json = string => { try { return JSON.parse(string); } catch { return null; } };\n\n/**\n * Check if a number is within a range\n * \n * @param {number} x - Value to check.\n * @param {number} min - Minimum value.\n * @param {number} max - Maximum value.\n * @returns {boolean} - True if in range.\n */\nconst range = (x, min, max) => (x - min) * (x - max) <= 0;\n\n/**\n * Check if a value is a function\n * \n * @param {any} obj - Value to check.\n * @returns {boolean} - True if function.\n */\nconst isFunction = obj => typeof obj === \"function\";\n\n/**\n * Check if a value is a plain object\n * \n * @param {any} obj - Value to check.\n * @returns {boolean} - True if an object.\n */\nconst isObject = obj => obj !== null && typeof obj === \"object\";\n\n/**\n * Check if a value is a string\n * \n * @param {any} obj - Value to check.\n * @returns {boolean} - True if a string.\n */\nconst isString = obj => typeof obj === \"string\";\n\n/**\n * Check if a value is a number\n * \n * @param {any} obj - Value to check.\n * @returns {boolean} - True if a number.\n */\nconst isNumber = obj => typeof obj === \"number\" && !isNaN(obj);\n\n/**\n * Check if an element is contained within another\n * \n * @param {HTMLElement} parent - The parent element.\n * @param {HTMLElement} child - The child element.\n * @returns {boolean} - True if `child` is inside `parent`, but not equal to it.\n */\nconst contains = (parent, child) => parent !== child && parent.contains(child);\n\n/**\n * Delay function execution until after a specified time\n * \n * @param {Function} fn - Function to debounce.\n * @param {number} delay - Delay in milliseconds.\n * @returns {Function} - Debounced function.\n */\nconst debounce = (fn, delay) => {\n\n    // Timeout reference\n    let timeout;\n\n    // Return debounced function\n    return (...args) => {\n\n        // Clear previous timeout\n        clearTimeout(timeout);\n\n        // Set new timeout\n        timeout = setTimeout(() => fn(...args), delay);\n    };\n};\n\n/**\n * Limit function execution to once within a time period\n * \n * @param {Function} fn - Function to throttle.\n * @param {number} limit - Limit in milliseconds.\n * @returns {Function} - Throttled function.\n */\nconst throttle = (fn, limit) => {\n\n    // Track last execution time\n    let lastCall = 0;\n\n    // Return throttled function\n    return (...args) => {\n\n        // Get current time\n        const now = Date.now();\n\n        // Execute if time has passed\n        if (now - lastCall >= limit) {\n\n            // Update last call\n            lastCall = now;\n\n            // Call function\n            fn(...args);\n        }\n    };\n};\n\n/**\n * Create an element with attributes and children\n * \n * @param {string} tag - HTML tag name.\n * @param {Object} [attrs={}] - Attributes to set.\n * @param {Array} [children=[]] - Child elements or text.\n * @returns {HTMLElement} - Created element.\n */\nconst element = (tag, attrs = {}, children = []) => {\n\n    // Create element\n    const el = document.createElement(tag);\n\n    // Assign attributes\n    Object.entries(attrs).forEach(([key, value]) => el.setAttribute(key, value));\n\n    // Append children\n    children.forEach(child => el.append(child instanceof Node ? child : document.createTextNode(child)));\n\n    // Return element\n    return el;\n};\n\n// Export module\nexport default { trim, json, range, isFunction, isObject, isString, isNumber, contains, debounce, throttle, element };", "import AnJS from './core.js';\n\n/**\n * Extend the `AnJS` prototype with new methods or multiple methods via an object.\n * \n * @param {string | Object} name - Method name or an object of methods.\n * @param {Function | Object} func - Method function if `name` is a string, otherwise ignored.\n * @param {boolean} [force=false] - Force override.\n */\nconst extend = function(name, func, force = false) {\n\n    // Handle object input recursively\n    if (typeof name === \"object\") {\n\n        // If second argument is boolean, use it as force\n        if (typeof func === \"boolean\") force = func;\n\n        // Extend each key in the object\n        return Object.keys(name).forEach(key => extend(key, name[key], force));\n    }\n\n    // Prevent overwriting existing methods unless forced\n    if (!force && AnJS.prototype.hasOwnProperty(name)) return;\n\n    // Assign method to prototype of AnJS\n    AnJS.prototype[name] = func;\n}\n\n// Export module\nexport default { extend };"],
  "mappings": "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",
  "names": ["bindings", "html", "element", "html", "$"]
}
